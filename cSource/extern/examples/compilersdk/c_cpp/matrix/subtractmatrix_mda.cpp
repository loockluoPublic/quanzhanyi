/*=================================================================
 *
 * SUBTRACTMATRIX_MDA
 * Sample driver code that uses the generic interface and
 * MATLAB Data API to call a C++ shared library created using 
 * MATLAB Compiler SDK. Demonstrates how to retrieve the results of
 * a call to feval.
 * Refer to the MATLAB Compiler SDK documentation for more
 * information.
 *
 * Copyright 2020 The MathWorks, Inc.
 *=================================================================*/

// Include the header file required to use the generic
// interface for the C++ shared library generated by the
// MATLAB Compiler SDK.
#include "MatlabCppSharedLib.hpp"
#include <iostream>

namespace mc = matlab::cpplib;
namespace md = matlab::data;

std::shared_ptr<mc::MATLABApplication> setup()
{
    auto mode = mc::MATLABApplicationMode::IN_PROCESS;
    // Specify MATLAB startup options
    std::vector<std::u16string> options = {};
    std::shared_ptr<mc::MATLABApplication> matlabApplication = 
        mc::initMATLABApplication(mode, options);
    return matlabApplication;
}

int mainFunc(std::shared_ptr<mc::MATLABApplication> app, const int /*argc*/,
    const char ** /*argv*/)
{        
    md::ArrayFactory factory;
    md::TypedArray<double> a1In = 
        factory.createArray<double>({1, 3}, {19.0, 28.0, 37.0});
    md::TypedArray<double> a2In = 
        factory.createArray<double>({1, 3}, {9.0, 8.0, 7.0});
    try {
        // The path to the CTF (library archive file) passed to 
        // initMATLABLibrary or initMATLABLibraryAsync may be either absolute
        // or relative. If it is relative, the following will be prepended
        // to it, in turn, in order to find the CTF:
        // - the directory named by the environment variable 
        // CPPSHARED_BASE_CTF_PATH, if defined
        // - the working directory
        // - the directory where the executable is located
        // - on Mac, the directory three levels above the directory
        // where the executable is located
        
        // If the CTF is not in one of these locations, do one of the following:
        // - copy the CTF
        // - move the CTF
        // - change the working directory ("cd") to the location of the CTF
        // - set the environment variable to the location of the CTF
        // - edit the code to change the path
        auto lib = mc::initMATLABLibrary(app, u"libsubtractmatrix.ctf");
        std::vector<md::Array> inputs{a1In, a2In};
        // Function is defined as: 
        //     function [afinal, astruct, acell] = subtractmatrix(a1, a2)
        auto result = lib->feval(u"subtractmatrix", 3, inputs);
        std::cout << "----------------------------------------------" 
            << std::endl;
        
        // Retrieve the first item (a numeric array) from the output.
        const md::TypedArray<double> mdaFinal = result[0];
        std::cout << "Results retrieved via the MATLAB Data API: " << std::endl;
        std::cout << "Elements of mdaFinal: " << std::endl;
        for (const auto & a: mdaFinal)
        {
            std::cout << a << " ";
        }
        std::cout << std::endl << std::endl;

        // Retrieve the second item (a struct array) from the output.
        const md::StructArray mdaStruct = result[1];
        // Retrieve the field with the name "elem1" from the struct array.
        std::cout << "Elements of mdaStruct[0][\"elem1\"]: " << std::endl;
        const md::TypedArray<double> mdaStructFirstElem = mdaStruct[0]["elem1"];
        for (const auto a: mdaStructFirstElem)
        {
            std::cout << a << " ";
        }
        std::cout << std::endl << std::endl;
        
        // Retrieve the third item (a cell array with two elements) from the 
        // output.
        const md::CellArray mdaCellArray = result[2];
        std::cout << "First element of mdaCellArray: " << std::endl;
        const md::CharArray mdaCharArray = mdaCellArray[0];
        std::string str = mdaCharArray.toAscii();
        std::cout << "'" << str << "'" << std::endl << std::endl;
        
        std::cout << "Second element of mdaCellArray: " << std::endl;
        const md::TypedArray<double> mdaScalar = mdaCellArray[1];
        std::cout << mdaScalar[0][0] << std::endl;
        std::cout << std::endl << std::endl;
        
    } catch (const std::exception & exc) {
        std::cerr << exc.what() << std::endl;
        return -1;
    }
    return 0;
}

// The main routine. On the Mac, the main thread runs the system code, and
// user code must be processed by a secondary thread. On other platforms, 
// the main thread runs both the system code and the user code.
int main(const int argc, const char * argv[]) 
{
    int ret = 0;
    try {
        auto matlabApplication = setup();
        ret = mc::runMain(mainFunc, std::move(matlabApplication), argc, argv);
        // Calling reset() on matlabApplication allows the user to control
        // when it is destroyed, which automatically cleans up its resources.
        // Here, the object would go out of scope and be destroyed at the end 
        // of the block anyway, even if reset() were not called.
        // Whether the matlabApplication object is explicitly or implicitly
        // destroyed, initMATLABApplication() cannot be called again within
        // the same process.
        matlabApplication.reset();
    } catch(const std::exception & exc) {
        std::cerr << exc.what() << std::endl;
        return -1;
    }
    return ret;
}
